{"ast":null,"code":"var _jsxFileName = \"/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordGrid = ({\n  words,\n  onWordFound,\n  hintedWord\n}) => {\n  _s();\n  const gridSize = 12; // Reduce grid size to make words closer\n  const [grid, setGrid] = useState(createInitialGrid());\n\n  // Combined word placement function\n  const placeWordInGrid = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX] = {\n        letter: word[i],\n        selected: false,\n        isPartOfHint: false\n      };\n    }\n  };\n\n  // Update useEffect to use placeWordInGrid\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    const centerStart = Math.floor(gridSize / 4); // Start placing words more centrally\n\n    words.forEach((word, index) => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3);\n        // Adjust starting positions to be more central\n        const startX = centerStart + Math.floor(Math.random() * (gridSize / 2));\n        const startY = centerStart + Math.floor(Math.random() * (gridSize / 2));\n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWordInGrid(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n\n  // Update the hint effect to use the correct grid state\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = grid.map(row => row.map(cell => ({\n        ...cell,\n        isPartOfHint: false\n      })));\n\n      // Search for the word in all possible directions\n      const directions = [[1, 0],\n      // horizontal\n      [0, 1],\n      // vertical\n      [1, 1] // diagonal\n      ];\n      let found = false;\n      outerLoop: for (let y = 0; y < gridSize; y++) {\n        for (let x = 0; x < gridSize; x++) {\n          for (const [dx, dy] of directions) {\n            if (canFindWordAt(x, y, hintedWord, dx, dy)) {\n              // Highlight the word\n              for (let i = 0; i < hintedWord.length; i++) {\n                const currentX = x + dx * i;\n                const currentY = y + dy * i;\n                newGrid[currentY][currentX].isPartOfHint = true;\n              }\n              found = true;\n              break outerLoop;\n            }\n          }\n        }\n      }\n      if (found) {\n        setGrid(newGrid);\n      }\n    }\n  }, [hintedWord]);\n  const canFindWordAt = (startX, startY, word, dx, dy) => {\n    if (startX + dx * (word.length - 1) >= gridSize || startY + dy * (word.length - 1) >= gridSize || startX + dx * (word.length - 1) < 0 || startY + dy * (word.length - 1) < 0) {\n      return false;\n    }\n    let matches = true;\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i]) {\n        matches = false;\n        break;\n      }\n    }\n    return matches;\n  };\n  const markHintedWord = (startX, startY, word) => {\n    const directions = [[0, 1],\n    // horizontal\n    [1, 0],\n    // vertical\n    [1, 1] // diagonal\n    ];\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n  function createInitialGrid() {\n    return Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n      selected: false\n    })));\n  }\n  const canPlaceWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n  const placeWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n  const [selection, setSelection] = useState([]);\n  const handleCellClick = (rowIndex, colIndex) => {\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join('');\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) {\n      // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? 'selected' : ''} ${hintedWord && cell.isPartOfHint ? 'hinted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: cell.letter\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 213,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 208,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"y3x8Kuv8ESgFkQnplQsjWoV9NsM=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","hintedWord","_s","gridSize","grid","setGrid","createInitialGrid","placeWordInGrid","word","x","y","direction","dx","dy","i","length","currentX","currentY","letter","selected","isPartOfHint","newGrid","centerStart","Math","floor","forEach","index","placed","attempts","random","startX","startY","canPlaceWord","map","row","cell","directions","found","outerLoop","canFindWordAt","matches","markHintedWord","Array","fill","String","fromCharCode","currentCell","placeWord","selection","setSelection","handleCellClick","rowIndex","colIndex","newSelection","col","selectedWord","pos","join","includes","className","children","some","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint?: boolean;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound, hintedWord }) => {\n  const gridSize = 12; // Reduce grid size to make words closer\n  const [grid, setGrid] = useState<Cell[][]>(createInitialGrid());\n\n  // Combined word placement function\n  const placeWordInGrid = (grid: Cell[][], word: string, x: number, y: number, direction: number): void => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX] = {\n        letter: word[i],\n        selected: false,\n        isPartOfHint: false\n      };\n    }\n  };\n\n  // Update useEffect to use placeWordInGrid\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    const centerStart = Math.floor(gridSize / 4); // Start placing words more centrally\n    \n    words.forEach((word, index) => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3);\n        // Adjust starting positions to be more central\n        const startX = centerStart + Math.floor(Math.random() * (gridSize / 2));\n        const startY = centerStart + Math.floor(Math.random() * (gridSize / 2));\n        \n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWordInGrid(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n\n  // Update the hint effect to use the correct grid state\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = grid.map(row => \n        row.map(cell => ({...cell, isPartOfHint: false}))\n      );\n\n      // Search for the word in all possible directions\n      const directions = [\n        [1, 0],  // horizontal\n        [0, 1],  // vertical\n        [1, 1]   // diagonal\n      ];\n\n      let found = false;\n      outerLoop: for (let y = 0; y < gridSize; y++) {\n        for (let x = 0; x < gridSize; x++) {\n          for (const [dx, dy] of directions) {\n            if (canFindWordAt(x, y, hintedWord, dx, dy)) {\n              // Highlight the word\n              for (let i = 0; i < hintedWord.length; i++) {\n                const currentX = x + dx * i;\n                const currentY = y + dy * i;\n                newGrid[currentY][currentX].isPartOfHint = true;\n              }\n              found = true;\n              break outerLoop;\n            }\n          }\n        }\n      }\n\n      if (found) {\n        setGrid(newGrid);\n      }\n    }\n  }, [hintedWord]);\n\n  const canFindWordAt = (startX: number, startY: number, word: string, dx: number, dy: number): boolean => {\n    if (startX + dx * (word.length - 1) >= gridSize || \n        startY + dy * (word.length - 1) >= gridSize ||\n        startX + dx * (word.length - 1) < 0 ||\n        startY + dy * (word.length - 1) < 0) {\n      return false;\n    }\n\n    let matches = true;\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i]) {\n        matches = false;\n        break;\n      }\n    }\n    return matches;\n  };\n\n  const markHintedWord = (startX: number, startY: number, word: string) => {\n    const directions = [\n      [0, 1],  // horizontal\n      [1, 0],  // vertical\n      [1, 1],  // diagonal\n    ];\n\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n\n  function createInitialGrid(): Cell[][] {\n    return Array(gridSize).fill(null).map(() =>\n      Array(gridSize).fill(null).map(() => ({\n        letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n        selected: false\n      }))\n    );\n  }\n\n  const canPlaceWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): boolean => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const placeWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): void => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n\n  const [selection, setSelection] = useState<Position[]>([]);\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) { // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                    ? 'selected'\n                    : ''\n                } ${\n                  hintedWord && cell.isPartOfHint ? 'hinted' : ''\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}