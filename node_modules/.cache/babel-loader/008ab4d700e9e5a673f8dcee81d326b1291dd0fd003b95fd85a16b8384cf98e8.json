{"ast":null,"code":"import React,{useState,useEffect}from'react';import{jsx as _jsx}from\"react/jsx-runtime\";const WordGrid=_ref=>{let{words,onWordFound,hintedWord}=_ref;const gridSize=12;function createInitialGrid(){return Array(gridSize).fill(null).map(()=>Array(gridSize).fill(null).map(()=>({letter:'',selected:false,isPartOfHint:false})));}const[grid,setGrid]=useState(createInitialGrid());const[selection,setSelection]=useState([]);const directions=[[1,0],// horizontal right\n[0,1],// vertical down\n[1,1],// diagonal down-right\n[-1,1],// diagonal down-left\n[-1,0],// horizontal left\n[0,-1],// vertical up\n[-1,-1],// diagonal up-left\n[1,-1]// diagonal up-right\n];useEffect(()=>{const newGrid=createInitialGrid();const sortedWords=[...words].sort((a,b)=>b.length-a.length);sortedWords.forEach(word=>{let placed=false;let attempts=0;while(!placed&&attempts<100){const directionIndex=Math.floor(Math.random()*directions.length);const[dx,dy]=directions[directionIndex];// Calculate valid boundaries for word placement\nlet startX=0;let startY=0;if(dx>0){startX=Math.floor(Math.random()*(gridSize-word.length+1));}else if(dx<0){startX=Math.floor(Math.random()*(gridSize-word.length+1))+(word.length-1);}else{startX=Math.floor(Math.random()*gridSize);}if(dy>0){startY=Math.floor(Math.random()*(gridSize-word.length+1));}else if(dy<0){startY=Math.floor(Math.random()*(gridSize-word.length+1))+(word.length-1);}else{startY=Math.floor(Math.random()*gridSize);}// Check if word can be placed by verifying each position\nconst canPlace=Array.from(word).every((letter,i)=>{const x=startX+dx*i;const y=startY+dy*i;return x>=0&&x<gridSize&&y>=0&&y<gridSize&&(!newGrid[y][x].letter||newGrid[y][x].letter===letter.toUpperCase());});if(canPlace){// Place the word in the grid\nArray.from(word).forEach((letter,i)=>{const x=startX+dx*i;const y=startY+dy*i;newGrid[y][x].letter=letter.toUpperCase();});placed=true;}attempts++;}});// Fill remaining cells with random letters\nfor(let y=0;y<gridSize;y++){for(let x=0;x<gridSize;x++){if(!newGrid[y][x].letter){newGrid[y][x].letter=String.fromCharCode(65+Math.floor(Math.random()*26));}}}setGrid(newGrid);},[words]);const handleCellClick=(rowIndex,colIndex)=>{const newSelection=[...selection,{row:rowIndex,col:colIndex}];setSelection(newSelection);const selectedWord=newSelection.map(pos=>grid[pos.row][pos.col].letter).join('');if(words.includes(selectedWord)){onWordFound(selectedWord);setSelection([]);}else if(newSelection.length>=10){// Reset if selection is too long\nsetSelection([]);}};return/*#__PURE__*/_jsx(\"div\",{className:\"word-grid\",children:/*#__PURE__*/_jsx(\"div\",{className:\"grid-container\",children:grid.map((row,rowIndex)=>/*#__PURE__*/_jsx(\"div\",{className:\"grid-row\",children:row.map((cell,colIndex)=>/*#__PURE__*/_jsx(\"div\",{className:`grid-cell ${selection.some(pos=>pos.row===rowIndex&&pos.col===colIndex)?'selected':''} ${hintedWord&&cell.isPartOfHint?'hinted':''}`,onClick:()=>handleCellClick(rowIndex,colIndex),children:cell.letter},`${rowIndex}-${colIndex}`))},rowIndex))})});};export default WordGrid;","map":{"version":3,"names":["React","useState","useEffect","jsx","_jsx","WordGrid","_ref","words","onWordFound","hintedWord","gridSize","createInitialGrid","Array","fill","map","letter","selected","isPartOfHint","grid","setGrid","selection","setSelection","directions","newGrid","sortedWords","sort","a","b","length","forEach","word","placed","attempts","directionIndex","Math","floor","random","dx","dy","startX","startY","canPlace","from","every","i","x","y","toUpperCase","String","fromCharCode","handleCellClick","rowIndex","colIndex","newSelection","row","col","selectedWord","pos","join","includes","className","children","cell","some","onClick"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint?: boolean;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound, hintedWord }) => {\n  const gridSize = 12;\n\n  function createInitialGrid(): Cell[][] {\n    return Array(gridSize).fill(null).map(() =>\n      Array(gridSize).fill(null).map(() => ({\n        letter: '',\n        selected: false,\n        isPartOfHint: false\n      }))\n    );\n  }\n\n  const [grid, setGrid] = useState<Cell[][]>(createInitialGrid());\n  const [selection, setSelection] = useState<Position[]>([]);\n\n  const directions = [\n    [1, 0],    // horizontal right\n    [0, 1],    // vertical down\n    [1, 1],    // diagonal down-right\n    [-1, 1],   // diagonal down-left\n    [-1, 0],   // horizontal left\n    [0, -1],   // vertical up\n    [-1, -1],  // diagonal up-left\n    [1, -1],   // diagonal up-right\n  ];\n\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\n  \n    sortedWords.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      \n      while (!placed && attempts < 100) {\n        const directionIndex = Math.floor(Math.random() * directions.length);\n        const [dx, dy] = directions[directionIndex];\n        \n        // Calculate valid boundaries for word placement\n        let startX: number = 0;\n        let startY: number = 0;\n  \n        if (dx > 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dx < 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startX = Math.floor(Math.random() * gridSize);\n        }\n  \n        if (dy > 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dy < 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startY = Math.floor(Math.random() * gridSize);\n        }\n  \n        // Check if word can be placed by verifying each position\n        const canPlace = Array.from(word).every((letter, i) => {\n          const x = startX + (dx * i);\n          const y = startY + (dy * i);\n          return x >= 0 && x < gridSize && y >= 0 && y < gridSize && \n                 (!newGrid[y][x].letter || newGrid[y][x].letter === letter.toUpperCase());\n        });\n\n        if (canPlace) {\n          // Place the word in the grid\n          Array.from(word).forEach((letter, i) => {\n            const x = startX + (dx * i);\n            const y = startY + (dy * i);\n            newGrid[y][x].letter = letter.toUpperCase();\n          });\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n\n    // Fill remaining cells with random letters\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize; x++) {\n        if (!newGrid[y][x].letter) {\n          newGrid[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n        }\n      }\n    }\n    \n    setGrid(newGrid);\n  }, [words]);\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) { // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                    ? 'selected'\n                    : ''\n                } ${\n                  hintedWord && cell.isPartOfHint ? 'hinted' : ''\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,QAAQ,CAAEC,SAAS,KAAQ,OAAO,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAmBnD,KAAM,CAAAC,QAAiC,CAAGC,IAAA,EAAwC,IAAvC,CAAEC,KAAK,CAAEC,WAAW,CAAEC,UAAW,CAAC,CAAAH,IAAA,CAC3E,KAAM,CAAAI,QAAQ,CAAG,EAAE,CAEnB,QAAS,CAAAC,iBAAiBA,CAAA,CAAa,CACrC,MAAO,CAAAC,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,IACpCF,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,KAAO,CACpCC,MAAM,CAAE,EAAE,CACVC,QAAQ,CAAE,KAAK,CACfC,YAAY,CAAE,KAChB,CAAC,CAAC,CACJ,CAAC,CACH,CAEA,KAAM,CAACC,IAAI,CAAEC,OAAO,CAAC,CAAGlB,QAAQ,CAAWU,iBAAiB,CAAC,CAAC,CAAC,CAC/D,KAAM,CAACS,SAAS,CAAEC,YAAY,CAAC,CAAGpB,QAAQ,CAAa,EAAE,CAAC,CAE1D,KAAM,CAAAqB,UAAU,CAAG,CACjB,CAAC,CAAC,CAAE,CAAC,CAAC,CAAK;AACX,CAAC,CAAC,CAAE,CAAC,CAAC,CAAK;AACX,CAAC,CAAC,CAAE,CAAC,CAAC,CAAK;AACX,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,CAAI;AACX,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,CAAI;AACX,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAAI;AACX,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAAG;AACX,CAAC,CAAC,CAAE,CAAC,CAAC,CAAK;AAAA,CACZ,CAEDpB,SAAS,CAAC,IAAM,CACd,KAAM,CAAAqB,OAAO,CAAGZ,iBAAiB,CAAC,CAAC,CACnC,KAAM,CAAAa,WAAW,CAAG,CAAC,GAAGjB,KAAK,CAAC,CAACkB,IAAI,CAAC,CAACC,CAAC,CAAEC,CAAC,GAAKA,CAAC,CAACC,MAAM,CAAGF,CAAC,CAACE,MAAM,CAAC,CAElEJ,WAAW,CAACK,OAAO,CAACC,IAAI,EAAI,CAC1B,GAAI,CAAAC,MAAM,CAAG,KAAK,CAClB,GAAI,CAAAC,QAAQ,CAAG,CAAC,CAEhB,MAAO,CAACD,MAAM,EAAIC,QAAQ,CAAG,GAAG,CAAE,CAChC,KAAM,CAAAC,cAAc,CAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAGd,UAAU,CAACM,MAAM,CAAC,CACpE,KAAM,CAACS,EAAE,CAAEC,EAAE,CAAC,CAAGhB,UAAU,CAACW,cAAc,CAAC,CAE3C;AACA,GAAI,CAAAM,MAAc,CAAG,CAAC,CACtB,GAAI,CAAAC,MAAc,CAAG,CAAC,CAEtB,GAAIH,EAAE,CAAG,CAAC,CAAE,CACVE,MAAM,CAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAI1B,QAAQ,CAAGoB,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CAAC,CACnE,CAAC,IAAM,IAAIS,EAAE,CAAG,CAAC,CAAE,CACjBE,MAAM,CAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAI1B,QAAQ,CAAGoB,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CAAC,EAAIE,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CACvF,CAAC,IAAM,CACLW,MAAM,CAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAG1B,QAAQ,CAAC,CAC/C,CAEA,GAAI4B,EAAE,CAAG,CAAC,CAAE,CACVE,MAAM,CAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAI1B,QAAQ,CAAGoB,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CAAC,CACnE,CAAC,IAAM,IAAIU,EAAE,CAAG,CAAC,CAAE,CACjBE,MAAM,CAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAI1B,QAAQ,CAAGoB,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CAAC,EAAIE,IAAI,CAACF,MAAM,CAAG,CAAC,CAAC,CACvF,CAAC,IAAM,CACLY,MAAM,CAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAG1B,QAAQ,CAAC,CAC/C,CAEA;AACA,KAAM,CAAA+B,QAAQ,CAAG7B,KAAK,CAAC8B,IAAI,CAACZ,IAAI,CAAC,CAACa,KAAK,CAAC,CAAC5B,MAAM,CAAE6B,CAAC,GAAK,CACrD,KAAM,CAAAC,CAAC,CAAGN,MAAM,CAAIF,EAAE,CAAGO,CAAE,CAC3B,KAAM,CAAAE,CAAC,CAAGN,MAAM,CAAIF,EAAE,CAAGM,CAAE,CAC3B,MAAO,CAAAC,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGnC,QAAQ,EAAIoC,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGpC,QAAQ,GAC/C,CAACa,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,EAAIQ,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,GAAKA,MAAM,CAACgC,WAAW,CAAC,CAAC,CAAC,CACjF,CAAC,CAAC,CAEF,GAAIN,QAAQ,CAAE,CACZ;AACA7B,KAAK,CAAC8B,IAAI,CAACZ,IAAI,CAAC,CAACD,OAAO,CAAC,CAACd,MAAM,CAAE6B,CAAC,GAAK,CACtC,KAAM,CAAAC,CAAC,CAAGN,MAAM,CAAIF,EAAE,CAAGO,CAAE,CAC3B,KAAM,CAAAE,CAAC,CAAGN,MAAM,CAAIF,EAAE,CAAGM,CAAE,CAC3BrB,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,CAAGA,MAAM,CAACgC,WAAW,CAAC,CAAC,CAC7C,CAAC,CAAC,CACFhB,MAAM,CAAG,IAAI,CACf,CACAC,QAAQ,EAAE,CACZ,CACF,CAAC,CAAC,CAEF;AACA,IAAK,GAAI,CAAAc,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGpC,QAAQ,CAAEoC,CAAC,EAAE,CAAE,CACjC,IAAK,GAAI,CAAAD,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGnC,QAAQ,CAAEmC,CAAC,EAAE,CAAE,CACjC,GAAI,CAACtB,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,CAAE,CACzBQ,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,CAAGiC,MAAM,CAACC,YAAY,CAAC,EAAE,CAAGf,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAG,EAAE,CAAC,CAAC,CACjF,CACF,CACF,CAEAjB,OAAO,CAACI,OAAO,CAAC,CAClB,CAAC,CAAE,CAAChB,KAAK,CAAC,CAAC,CAEX,KAAM,CAAA2C,eAAe,CAAGA,CAACC,QAAgB,CAAEC,QAAgB,GAAW,CACpE,KAAM,CAAAC,YAAY,CAAG,CAAC,GAAGjC,SAAS,CAAE,CAAEkC,GAAG,CAAEH,QAAQ,CAAEI,GAAG,CAAEH,QAAS,CAAC,CAAC,CACrE/B,YAAY,CAACgC,YAAY,CAAC,CAE1B,KAAM,CAAAG,YAAY,CAAGH,YAAY,CAC9BvC,GAAG,CAAC2C,GAAG,EAAIvC,IAAI,CAACuC,GAAG,CAACH,GAAG,CAAC,CAACG,GAAG,CAACF,GAAG,CAAC,CAACxC,MAAM,CAAC,CACzC2C,IAAI,CAAC,EAAE,CAAC,CAEX,GAAInD,KAAK,CAACoD,QAAQ,CAACH,YAAY,CAAC,CAAE,CAChChD,WAAW,CAACgD,YAAY,CAAC,CACzBnC,YAAY,CAAC,EAAE,CAAC,CAClB,CAAC,IAAM,IAAIgC,YAAY,CAACzB,MAAM,EAAI,EAAE,CAAE,CAAE;AACtCP,YAAY,CAAC,EAAE,CAAC,CAClB,CACF,CAAC,CAED,mBACEjB,IAAA,QAAKwD,SAAS,CAAC,WAAW,CAAAC,QAAA,cACxBzD,IAAA,QAAKwD,SAAS,CAAC,gBAAgB,CAAAC,QAAA,CAC5B3C,IAAI,CAACJ,GAAG,CAAC,CAACwC,GAAG,CAAEH,QAAQ,gBACtB/C,IAAA,QAAoBwD,SAAS,CAAC,UAAU,CAAAC,QAAA,CACrCP,GAAG,CAACxC,GAAG,CAAC,CAACgD,IAAI,CAAEV,QAAQ,gBACtBhD,IAAA,QAEEwD,SAAS,CAAE,aACTxC,SAAS,CAAC2C,IAAI,CAACN,GAAG,EAAIA,GAAG,CAACH,GAAG,GAAKH,QAAQ,EAAIM,GAAG,CAACF,GAAG,GAAKH,QAAQ,CAAC,CAC/D,UAAU,CACV,EAAE,IAEN3C,UAAU,EAAIqD,IAAI,CAAC7C,YAAY,CAAG,QAAQ,CAAG,EAAE,EAC9C,CACH+C,OAAO,CAAEA,CAAA,GAAMd,eAAe,CAACC,QAAQ,CAAEC,QAAQ,CAAE,CAAAS,QAAA,CAElDC,IAAI,CAAC/C,MAAM,EAVP,GAAGoC,QAAQ,IAAIC,QAAQ,EAWzB,CACN,CAAC,EAfMD,QAgBL,CACN,CAAC,CACC,CAAC,CACH,CAAC,CAEV,CAAC,CAED,cAAe,CAAA9C,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}