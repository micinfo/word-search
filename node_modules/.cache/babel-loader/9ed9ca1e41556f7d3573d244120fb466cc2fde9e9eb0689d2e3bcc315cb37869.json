{"ast":null,"code":"var _jsxFileName = \"/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordGrid = ({\n  words,\n  onWordFound,\n  hintedWord\n}) => {\n  _s();\n  const gridSize = 15;\n  const [grid, setGrid] = useState(createInitialGrid());\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = [...grid];\n      // Reset previous hints\n      newGrid.forEach(row => row.forEach(cell => cell.isPartOfHint = false));\n\n      // Find and mark the hinted word\n      for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n          if (checkWordAtPosition(i, j, hintedWord)) {\n            markHintedWord(i, j, hintedWord);\n          }\n        }\n      }\n      setGrid(newGrid);\n    }\n  }, [hintedWord]);\n  const checkWordAtPosition = (startX, startY, word) => {\n    const directions = [[0, 1],\n    // horizontal\n    [1, 0],\n    // vertical\n    [1, 1] // diagonal\n    ];\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) return true;\n    }\n    return false;\n  };\n  const markHintedWord = (startX, startY, word) => {\n    const directions = [[0, 1],\n    // horizontal\n    [1, 0],\n    // vertical\n    [1, 1] // diagonal\n    ];\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n  function createInitialGrid() {\n    return Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n      selected: false\n    })));\n  }\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    words.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3); // 0: horizontal, 1: vertical, 2: diagonal\n        const startX = Math.floor(Math.random() * (gridSize - word.length));\n        const startY = Math.floor(Math.random() * (gridSize - word.length));\n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWord(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n  const canPlaceWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n  const placeWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n  const [selection, setSelection] = useState([]);\n  const handleCellClick = (rowIndex, colIndex) => {\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join('');\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) {\n      // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? 'selected' : ''} ${hintedWord && cell.isPartOfHint ? 'hinted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: cell.letter\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 170,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"y3x8Kuv8ESgFkQnplQsjWoV9NsM=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","hintedWord","_s","gridSize","grid","setGrid","createInitialGrid","newGrid","forEach","row","cell","isPartOfHint","i","j","checkWordAtPosition","markHintedWord","startX","startY","word","directions","dx","dy","matches","length","x","y","letter","Array","fill","map","String","fromCharCode","Math","floor","random","selected","placed","attempts","direction","canPlaceWord","placeWord","currentX","currentY","currentCell","selection","setSelection","handleCellClick","rowIndex","colIndex","newSelection","col","selectedWord","pos","join","includes","className","children","some","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint?: boolean;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound, hintedWord }) => {\n  const gridSize = 15;\n  const [grid, setGrid] = useState<Cell[][]>(createInitialGrid());\n\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = [...grid];\n      // Reset previous hints\n      newGrid.forEach(row => row.forEach(cell => cell.isPartOfHint = false));\n      \n      // Find and mark the hinted word\n      for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n          if (checkWordAtPosition(i, j, hintedWord)) {\n            markHintedWord(i, j, hintedWord);\n          }\n        }\n      }\n      setGrid(newGrid);\n    }\n  }, [hintedWord]);\n\n  const checkWordAtPosition = (startX: number, startY: number, word: string): boolean => {\n    const directions = [\n      [0, 1],  // horizontal\n      [1, 0],  // vertical\n      [1, 1],  // diagonal\n    ];\n\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) return true;\n    }\n    return false;\n  };\n\n  const markHintedWord = (startX: number, startY: number, word: string) => {\n    const directions = [\n      [0, 1],  // horizontal\n      [1, 0],  // vertical\n      [1, 1],  // diagonal\n    ];\n\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n\n  function createInitialGrid(): Cell[][] {\n    return Array(gridSize).fill(null).map(() =>\n      Array(gridSize).fill(null).map(() => ({\n        letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n        selected: false\n      }))\n    );\n  }\n\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    words.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3); // 0: horizontal, 1: vertical, 2: diagonal\n        const startX = Math.floor(Math.random() * (gridSize - word.length));\n        const startY = Math.floor(Math.random() * (gridSize - word.length));\n        \n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWord(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n\n  const canPlaceWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): boolean => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const placeWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): void => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n\n  const [selection, setSelection] = useState<Position[]>([]);\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) { // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                    ? 'selected'\n                    : ''\n                } ${\n                  hintedWord && cell.isPartOfHint ? 'hinted' : ''\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}