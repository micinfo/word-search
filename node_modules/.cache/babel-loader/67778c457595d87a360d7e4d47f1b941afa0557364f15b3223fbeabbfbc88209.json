{"ast":null,"code":"var _jsxFileName = \"/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordGrid = ({\n  words,\n  onWordFound,\n  hintedWord\n}) => {\n  _s();\n  const gridSize = 12;\n  function createInitialGrid() {\n    return Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: '',\n      selected: false,\n      isPartOfHint: false\n    })));\n  }\n  const [grid, setGrid] = useState(createInitialGrid());\n  const [selection, setSelection] = useState([]);\n  const directions = [[1, 0],\n  // horizontal right\n  [0, 1],\n  // vertical down\n  [1, 1],\n  // diagonal down-right\n  [-1, 1],\n  // diagonal down-left\n  [-1, 0],\n  // horizontal left\n  [0, -1],\n  // vertical up\n  [-1, -1],\n  // diagonal up-left\n  [1, -1] // diagonal up-right\n  ];\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\n    sortedWords.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const directionIndex = Math.floor(Math.random() * directions.length);\n        const [dx, dy] = directions[directionIndex];\n\n        // Calculate valid boundaries for word placement\n        let startX = 0;\n        let startY = 0;\n        if (dx > 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dx < 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startX = Math.floor(Math.random() * gridSize);\n        }\n        if (dy > 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dy < 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startY = Math.floor(Math.random() * gridSize);\n        }\n\n        // Check if word can be placed by verifying each position\n        const canPlace = Array.from(word).every((letter, i) => {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          return x >= 0 && x < gridSize && y >= 0 && y < gridSize && (!newGrid[y][x].letter || newGrid[y][x].letter === letter.toUpperCase());\n        });\n        if (canPlace) {\n          // Place the word in the grid\n          Array.from(word).forEach((letter, i) => {\n            const x = startX + dx * i;\n            const y = startY + dy * i;\n            newGrid[y][x].letter = letter.toUpperCase();\n          });\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n\n    // Fill remaining cells with random letters\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize; x++) {\n        if (!newGrid[y][x].letter) {\n          newGrid[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n        }\n      }\n    }\n    setGrid(newGrid);\n  }, [words]);\n  const handleCellClick = (rowIndex, colIndex) => {\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join('');\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) {\n      // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? 'selected' : ''} ${hintedWord && cell.isPartOfHint ? 'hinted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: cell.letter\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 134,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 132,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 129,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"LSV+zFlsQTMWNE6X7llQ485WV0w=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","hintedWord","_s","gridSize","createInitialGrid","Array","fill","map","letter","selected","isPartOfHint","grid","setGrid","selection","setSelection","directions","newGrid","sortedWords","sort","a","b","length","forEach","word","placed","attempts","directionIndex","Math","floor","random","dx","dy","startX","startY","canPlace","from","every","i","x","y","toUpperCase","String","fromCharCode","handleCellClick","rowIndex","colIndex","newSelection","row","col","selectedWord","pos","join","includes","className","children","cell","some","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint?: boolean;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound, hintedWord }) => {\n  const gridSize = 12;\n\n  function createInitialGrid(): Cell[][] {\n    return Array(gridSize).fill(null).map(() =>\n      Array(gridSize).fill(null).map(() => ({\n        letter: '',\n        selected: false,\n        isPartOfHint: false\n      }))\n    );\n  }\n\n  const [grid, setGrid] = useState<Cell[][]>(createInitialGrid());\n  const [selection, setSelection] = useState<Position[]>([]);\n\n  const directions = [\n    [1, 0],    // horizontal right\n    [0, 1],    // vertical down\n    [1, 1],    // diagonal down-right\n    [-1, 1],   // diagonal down-left\n    [-1, 0],   // horizontal left\n    [0, -1],   // vertical up\n    [-1, -1],  // diagonal up-left\n    [1, -1],   // diagonal up-right\n  ];\n\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\n  \n    sortedWords.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      \n      while (!placed && attempts < 100) {\n        const directionIndex = Math.floor(Math.random() * directions.length);\n        const [dx, dy] = directions[directionIndex];\n        \n        // Calculate valid boundaries for word placement\n        let startX: number = 0;\n        let startY: number = 0;\n  \n        if (dx > 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dx < 0) {\n          startX = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startX = Math.floor(Math.random() * gridSize);\n        }\n  \n        if (dy > 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1));\n        } else if (dy < 0) {\n          startY = Math.floor(Math.random() * (gridSize - word.length + 1)) + (word.length - 1);\n        } else {\n          startY = Math.floor(Math.random() * gridSize);\n        }\n  \n        // Check if word can be placed by verifying each position\n        const canPlace = Array.from(word).every((letter, i) => {\n          const x = startX + (dx * i);\n          const y = startY + (dy * i);\n          return x >= 0 && x < gridSize && y >= 0 && y < gridSize && \n                 (!newGrid[y][x].letter || newGrid[y][x].letter === letter.toUpperCase());\n        });\n\n        if (canPlace) {\n          // Place the word in the grid\n          Array.from(word).forEach((letter, i) => {\n            const x = startX + (dx * i);\n            const y = startY + (dy * i);\n            newGrid[y][x].letter = letter.toUpperCase();\n          });\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n\n    // Fill remaining cells with random letters\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize; x++) {\n        if (!newGrid[y][x].letter) {\n          newGrid[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n        }\n      }\n    }\n    \n    setGrid(newGrid);\n  }, [words]);\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) { // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                    ? 'selected'\n                    : ''\n                } ${\n                  hintedWord && cell.isPartOfHint ? 'hinted' : ''\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAmBnD,MAAMC,QAAiC,GAAGA,CAAC;EAAEC,KAAK;EAAEC,WAAW;EAAEC;AAAW,CAAC,KAAK;EAAAC,EAAA;EAChF,MAAMC,QAAQ,GAAG,EAAE;EAEnB,SAASC,iBAAiBA,CAAA,EAAa;IACrC,OAAOC,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MACpCF,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,OAAO;MACpCC,MAAM,EAAE,EAAE;MACVC,QAAQ,EAAE,KAAK;MACfC,YAAY,EAAE;IAChB,CAAC,CAAC,CACJ,CAAC;EACH;EAEA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGlB,QAAQ,CAAWU,iBAAiB,CAAC,CAAC,CAAC;EAC/D,MAAM,CAACS,SAAS,EAAEC,YAAY,CAAC,GAAGpB,QAAQ,CAAa,EAAE,CAAC;EAE1D,MAAMqB,UAAU,GAAG,CACjB,CAAC,CAAC,EAAE,CAAC,CAAC;EAAK;EACX,CAAC,CAAC,EAAE,CAAC,CAAC;EAAK;EACX,CAAC,CAAC,EAAE,CAAC,CAAC;EAAK;EACX,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAAI;EACX,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAAI;EACX,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAI;EACX,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAG;EACX,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAI;EAAA,CACZ;EAEDpB,SAAS,CAAC,MAAM;IACd,MAAMqB,OAAO,GAAGZ,iBAAiB,CAAC,CAAC;IACnC,MAAMa,WAAW,GAAG,CAAC,GAAGlB,KAAK,CAAC,CAACmB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACC,MAAM,GAAGF,CAAC,CAACE,MAAM,CAAC;IAElEJ,WAAW,CAACK,OAAO,CAACC,IAAI,IAAI;MAC1B,IAAIC,MAAM,GAAG,KAAK;MAClB,IAAIC,QAAQ,GAAG,CAAC;MAEhB,OAAO,CAACD,MAAM,IAAIC,QAAQ,GAAG,GAAG,EAAE;QAChC,MAAMC,cAAc,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGd,UAAU,CAACM,MAAM,CAAC;QACpE,MAAM,CAACS,EAAE,EAAEC,EAAE,CAAC,GAAGhB,UAAU,CAACW,cAAc,CAAC;;QAE3C;QACA,IAAIM,MAAc,GAAG,CAAC;QACtB,IAAIC,MAAc,GAAG,CAAC;QAEtB,IAAIH,EAAE,GAAG,CAAC,EAAE;UACVE,MAAM,GAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAI1B,QAAQ,GAAGoB,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC,CAAC;QACnE,CAAC,MAAM,IAAIS,EAAE,GAAG,CAAC,EAAE;UACjBE,MAAM,GAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAI1B,QAAQ,GAAGoB,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC,CAAC,IAAIE,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC;QACvF,CAAC,MAAM;UACLW,MAAM,GAAGL,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG1B,QAAQ,CAAC;QAC/C;QAEA,IAAI4B,EAAE,GAAG,CAAC,EAAE;UACVE,MAAM,GAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAI1B,QAAQ,GAAGoB,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC,CAAC;QACnE,CAAC,MAAM,IAAIU,EAAE,GAAG,CAAC,EAAE;UACjBE,MAAM,GAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAI1B,QAAQ,GAAGoB,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC,CAAC,IAAIE,IAAI,CAACF,MAAM,GAAG,CAAC,CAAC;QACvF,CAAC,MAAM;UACLY,MAAM,GAAGN,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG1B,QAAQ,CAAC;QAC/C;;QAEA;QACA,MAAM+B,QAAQ,GAAG7B,KAAK,CAAC8B,IAAI,CAACZ,IAAI,CAAC,CAACa,KAAK,CAAC,CAAC5B,MAAM,EAAE6B,CAAC,KAAK;UACrD,MAAMC,CAAC,GAAGN,MAAM,GAAIF,EAAE,GAAGO,CAAE;UAC3B,MAAME,CAAC,GAAGN,MAAM,GAAIF,EAAE,GAAGM,CAAE;UAC3B,OAAOC,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGnC,QAAQ,IAAIoC,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGpC,QAAQ,KAC/C,CAACa,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,IAAIQ,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,KAAKA,MAAM,CAACgC,WAAW,CAAC,CAAC,CAAC;QACjF,CAAC,CAAC;QAEF,IAAIN,QAAQ,EAAE;UACZ;UACA7B,KAAK,CAAC8B,IAAI,CAACZ,IAAI,CAAC,CAACD,OAAO,CAAC,CAACd,MAAM,EAAE6B,CAAC,KAAK;YACtC,MAAMC,CAAC,GAAGN,MAAM,GAAIF,EAAE,GAAGO,CAAE;YAC3B,MAAME,CAAC,GAAGN,MAAM,GAAIF,EAAE,GAAGM,CAAE;YAC3BrB,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,GAAGA,MAAM,CAACgC,WAAW,CAAC,CAAC;UAC7C,CAAC,CAAC;UACFhB,MAAM,GAAG,IAAI;QACf;QACAC,QAAQ,EAAE;MACZ;IACF,CAAC,CAAC;;IAEF;IACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,QAAQ,EAAEoC,CAAC,EAAE,EAAE;MACjC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,QAAQ,EAAEmC,CAAC,EAAE,EAAE;QACjC,IAAI,CAACtB,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,EAAE;UACzBQ,OAAO,CAACuB,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC9B,MAAM,GAAGiC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGf,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QACjF;MACF;IACF;IAEAjB,OAAO,CAACI,OAAO,CAAC;EAClB,CAAC,EAAE,CAACjB,KAAK,CAAC,CAAC;EAEX,MAAM4C,eAAe,GAAGA,CAACC,QAAgB,EAAEC,QAAgB,KAAW;IACpE,MAAMC,YAAY,GAAG,CAAC,GAAGjC,SAAS,EAAE;MAAEkC,GAAG,EAAEH,QAAQ;MAAEI,GAAG,EAAEH;IAAS,CAAC,CAAC;IACrE/B,YAAY,CAACgC,YAAY,CAAC;IAE1B,MAAMG,YAAY,GAAGH,YAAY,CAC9BvC,GAAG,CAAC2C,GAAG,IAAIvC,IAAI,CAACuC,GAAG,CAACH,GAAG,CAAC,CAACG,GAAG,CAACF,GAAG,CAAC,CAACxC,MAAM,CAAC,CACzC2C,IAAI,CAAC,EAAE,CAAC;IAEX,IAAIpD,KAAK,CAACqD,QAAQ,CAACH,YAAY,CAAC,EAAE;MAChCjD,WAAW,CAACiD,YAAY,CAAC;MACzBnC,YAAY,CAAC,EAAE,CAAC;IAClB,CAAC,MAAM,IAAIgC,YAAY,CAACzB,MAAM,IAAI,EAAE,EAAE;MAAE;MACtCP,YAAY,CAAC,EAAE,CAAC;IAClB;EACF,CAAC;EAED,oBACEjB,OAAA;IAAKwD,SAAS,EAAC,WAAW;IAAAC,QAAA,eACxBzD,OAAA;MAAKwD,SAAS,EAAC,gBAAgB;MAAAC,QAAA,EAC5B3C,IAAI,CAACJ,GAAG,CAAC,CAACwC,GAAG,EAAEH,QAAQ,kBACtB/C,OAAA;QAAoBwD,SAAS,EAAC,UAAU;QAAAC,QAAA,EACrCP,GAAG,CAACxC,GAAG,CAAC,CAACgD,IAAI,EAAEV,QAAQ,kBACtBhD,OAAA;UAEEwD,SAAS,EAAE,aACTxC,SAAS,CAAC2C,IAAI,CAACN,GAAG,IAAIA,GAAG,CAACH,GAAG,KAAKH,QAAQ,IAAIM,GAAG,CAACF,GAAG,KAAKH,QAAQ,CAAC,GAC/D,UAAU,GACV,EAAE,IAEN5C,UAAU,IAAIsD,IAAI,CAAC7C,YAAY,GAAG,QAAQ,GAAG,EAAE,EAC9C;UACH+C,OAAO,EAAEA,CAAA,KAAMd,eAAe,CAACC,QAAQ,EAAEC,QAAQ,CAAE;UAAAS,QAAA,EAElDC,IAAI,CAAC/C;QAAM,GAVP,GAAGoC,QAAQ,IAAIC,QAAQ,EAAE;UAAAa,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAW3B,CACN;MAAC,GAfMjB,QAAQ;QAAAc,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAgBb,CACN;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACC;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEV,CAAC;AAAC3D,EAAA,CArIIJ,QAAiC;AAAAgE,EAAA,GAAjChE,QAAiC;AAuIvC,eAAeA,QAAQ;AAAC,IAAAgE,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}