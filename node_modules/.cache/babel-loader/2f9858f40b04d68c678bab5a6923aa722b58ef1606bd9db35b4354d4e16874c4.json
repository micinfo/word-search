{"ast":null,"code":"var _jsxFileName = \"/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordGrid = ({\n  words,\n  onWordFound,\n  hintedWord\n}) => {\n  _s();\n  const gridSize = 15;\n  const [grid, setGrid] = useState(createInitialGrid());\n\n  // Combined word placement function\n  const placeWordInGrid = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX] = {\n        letter: word[i],\n        selected: false,\n        isPartOfHint: false\n      };\n    }\n  };\n\n  // Update useEffect to use placeWordInGrid\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    words.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3);\n        const startX = Math.floor(Math.random() * (gridSize - word.length));\n        const startY = Math.floor(Math.random() * (gridSize - word.length));\n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWordInGrid(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n\n  // Update the hint effect to use the correct grid state\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = grid.map(row => row.map(cell => ({\n        ...cell,\n        isPartOfHint: false\n      })));\n\n      // Search for the word in all possible directions\n      const directions = [[1, 0],\n      // horizontal\n      [0, 1],\n      // vertical\n      [1, 1] // diagonal\n      ];\n      let found = false;\n      outerLoop: for (let y = 0; y < gridSize; y++) {\n        for (let x = 0; x < gridSize; x++) {\n          for (const [dx, dy] of directions) {\n            if (canFindWordAt(x, y, hintedWord, dx, dy)) {\n              // Highlight the word\n              for (let i = 0; i < hintedWord.length; i++) {\n                const currentX = x + dx * i;\n                const currentY = y + dy * i;\n                newGrid[currentY][currentX].isPartOfHint = true;\n              }\n              found = true;\n              break outerLoop;\n            }\n          }\n        }\n      }\n      if (found) {\n        setGrid(newGrid);\n      }\n    }\n  }, [hintedWord]);\n  const canFindWordAt = (startX, startY, word, dx, dy) => {\n    if (startX + dx * (word.length - 1) >= gridSize || startY + dy * (word.length - 1) >= gridSize || startX + dx * (word.length - 1) < 0 || startY + dy * (word.length - 1) < 0) {\n      return false;\n    }\n    let matches = true;\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i]) {\n        matches = false;\n        break;\n      }\n    }\n    return matches;\n  };\n  const markHintedWord = (startX, startY, word) => {\n    const directions = [[0, 1],\n    // horizontal\n    [1, 0],\n    // vertical\n    [1, 1] // diagonal\n    ];\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n  function createInitialGrid() {\n    return Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n      selected: false\n    })));\n  }\n  const canPlaceWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n  const placeWord = (grid, word, x, y, direction) => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n  const [selection, setSelection] = useState([]);\n  const handleCellClick = (rowIndex, colIndex) => {\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join('');\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) {\n      // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? 'selected' : ''} ${hintedWord && cell.isPartOfHint ? 'hinted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: cell.letter\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 210,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 208,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 206,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 205,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"y3x8Kuv8ESgFkQnplQsjWoV9NsM=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","hintedWord","_s","gridSize","grid","setGrid","createInitialGrid","placeWordInGrid","word","x","y","direction","dx","dy","i","length","currentX","currentY","letter","selected","isPartOfHint","newGrid","forEach","placed","attempts","Math","floor","random","startX","startY","canPlaceWord","map","row","cell","directions","found","outerLoop","canFindWordAt","matches","markHintedWord","Array","fill","String","fromCharCode","currentCell","placeWord","selection","setSelection","handleCellClick","rowIndex","colIndex","newSelection","col","selectedWord","pos","join","includes","className","children","some","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint?: boolean;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound, hintedWord }) => {\n  const gridSize = 15;\n  const [grid, setGrid] = useState<Cell[][]>(createInitialGrid());\n\n  // Combined word placement function\n  const placeWordInGrid = (grid: Cell[][], word: string, x: number, y: number, direction: number): void => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX] = {\n        letter: word[i],\n        selected: false,\n        isPartOfHint: false\n      };\n    }\n  };\n\n  // Update useEffect to use placeWordInGrid\n  useEffect(() => {\n    const newGrid = createInitialGrid();\n    words.forEach(word => {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < 100) {\n        const direction = Math.floor(Math.random() * 3);\n        const startX = Math.floor(Math.random() * (gridSize - word.length));\n        const startY = Math.floor(Math.random() * (gridSize - word.length));\n        \n        if (canPlaceWord(newGrid, word, startX, startY, direction)) {\n          placeWordInGrid(newGrid, word, startX, startY, direction);\n          placed = true;\n        }\n        attempts++;\n      }\n    });\n    setGrid(newGrid);\n  }, [words]);\n\n  // Update the hint effect to use the correct grid state\n  useEffect(() => {\n    if (hintedWord) {\n      const newGrid = grid.map(row => \n        row.map(cell => ({...cell, isPartOfHint: false}))\n      );\n\n      // Search for the word in all possible directions\n      const directions = [\n        [1, 0],  // horizontal\n        [0, 1],  // vertical\n        [1, 1]   // diagonal\n      ];\n\n      let found = false;\n      outerLoop: for (let y = 0; y < gridSize; y++) {\n        for (let x = 0; x < gridSize; x++) {\n          for (const [dx, dy] of directions) {\n            if (canFindWordAt(x, y, hintedWord, dx, dy)) {\n              // Highlight the word\n              for (let i = 0; i < hintedWord.length; i++) {\n                const currentX = x + dx * i;\n                const currentY = y + dy * i;\n                newGrid[currentY][currentX].isPartOfHint = true;\n              }\n              found = true;\n              break outerLoop;\n            }\n          }\n        }\n      }\n\n      if (found) {\n        setGrid(newGrid);\n      }\n    }\n  }, [hintedWord]);\n\n  const canFindWordAt = (startX: number, startY: number, word: string, dx: number, dy: number): boolean => {\n    if (startX + dx * (word.length - 1) >= gridSize || \n        startY + dy * (word.length - 1) >= gridSize ||\n        startX + dx * (word.length - 1) < 0 ||\n        startY + dy * (word.length - 1) < 0) {\n      return false;\n    }\n\n    let matches = true;\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i]) {\n        matches = false;\n        break;\n      }\n    }\n    return matches;\n  };\n\n  const markHintedWord = (startX: number, startY: number, word: string) => {\n    const directions = [\n      [0, 1],  // horizontal\n      [1, 0],  // vertical\n      [1, 1],  // diagonal\n    ];\n\n    for (const [dx, dy] of directions) {\n      let matches = true;\n      for (let i = 0; i < word.length; i++) {\n        const x = startX + dx * i;\n        const y = startY + dy * i;\n        if (x >= gridSize || y >= gridSize || grid[y][x].letter !== word[i]) {\n          matches = false;\n          break;\n        }\n      }\n      if (matches) {\n        for (let i = 0; i < word.length; i++) {\n          const x = startX + dx * i;\n          const y = startY + dy * i;\n          grid[y][x].isPartOfHint = true;\n        }\n        return;\n      }\n    }\n  };\n\n  function createInitialGrid(): Cell[][] {\n    return Array(gridSize).fill(null).map(() =>\n      Array(gridSize).fill(null).map(() => ({\n        letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n        selected: false\n      }))\n    );\n  }\n\n  const canPlaceWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): boolean => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    if (x + dx * word.length > gridSize || y + dy * word.length > gridSize) {\n      return false;\n    }\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      const currentCell = grid[currentY][currentX];\n      if (currentCell.letter !== word[i] && currentCell.letter !== '') {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const placeWord = (grid: Cell[][], word: string, x: number, y: number, direction: number): void => {\n    const dx = direction === 0 ? 1 : direction === 2 ? 1 : 0;\n    const dy = direction === 1 ? 1 : direction === 2 ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentX = x + dx * i;\n      const currentY = y + dy * i;\n      grid[currentY][currentX].letter = word[i];\n    }\n  };\n\n  const [selection, setSelection] = useState<Position[]>([]);\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n      setSelection([]);\n    } else if (newSelection.length >= 10) { // Reset if selection is too long\n      setSelection([]);\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                    ? 'selected'\n                    : ''\n                } ${\n                  hintedWord && cell.isPartOfHint ? 'hinted' : ''\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}