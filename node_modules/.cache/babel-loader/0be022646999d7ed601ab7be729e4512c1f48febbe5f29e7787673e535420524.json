{"ast":null,"code":"var _jsxFileName = \"/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordGrid = ({\n  words,\n  onWordFound\n}) => {\n  _s();\n  const gridSize = 15;\n  const [grid, setGrid] = useState([]);\n  const [selection, setSelection] = useState([]);\n  useEffect(() => {\n    generateGrid();\n  }, []);\n  const generateGrid = () => {\n    let newGrid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n      selected: false\n    })));\n    words.forEach(word => {\n      placeWord(newGrid, word);\n    });\n    setGrid(newGrid);\n  };\n  const placeWord = (grid, word) => {\n    const directions = [[0, 1],\n    // horizontal\n    [1, 0],\n    // vertical\n    [1, 1] // diagonal\n    ];\n    let placed = false;\n    while (!placed) {\n      const direction = directions[Math.floor(Math.random() * directions.length)];\n      const startX = Math.floor(Math.random() * gridSize);\n      const startY = Math.floor(Math.random() * gridSize);\n      if (canPlaceWord(grid, word, startX, startY, direction)) {\n        placeWordAt(grid, word, startX, startY, direction);\n        placed = true;\n      }\n    }\n  };\n  const canPlaceWord = (grid, word, startX, startY, [dx, dy]) => {\n    if (startX + dx * word.length >= gridSize || startY + dy * word.length >= gridSize) return false;\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i] && grid[y][x].letter !== String.fromCharCode(65 + Math.floor(Math.random() * 26))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const placeWordAt = (grid, word, startX, startY, [dx, dy]) => {\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      grid[y][x].letter = word[i];\n    }\n  };\n  const handleCellClick = (rowIndex, colIndex) => {\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join('');\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n    }\n    setTimeout(() => setSelection([]), 500);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-row\",\n      children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? 'selected' : ''}`,\n        onClick: () => handleCellClick(rowIndex, colIndex),\n        children: cell.letter\n      }, `${rowIndex}-${colIndex}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 119,\n        columnNumber: 13\n      }, this))\n    }, rowIndex, false, {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 115,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"CkRDC0RsM49WqWEi/Cpun9gvR7o=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","_s","gridSize","grid","setGrid","selection","setSelection","generateGrid","newGrid","Array","fill","map","letter","String","fromCharCode","Math","floor","random","selected","forEach","word","placeWord","directions","placed","direction","length","startX","startY","canPlaceWord","placeWordAt","dx","dy","i","x","y","handleCellClick","rowIndex","colIndex","newSelection","row","col","selectedWord","pos","join","includes","setTimeout","className","children","cell","some","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/micinfo/Documents/PROJECT/mic/learning/word-search/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n}\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n}\n\ntype Direction = [number, number];\n\nconst WordGrid: React.FC<WordGridProps> = ({ words, onWordFound }) => {\n  const gridSize = 15;\n  const [grid, setGrid] = useState<Cell[][]>([]);\n  const [selection, setSelection] = useState<Position[]>([]);\n  \n  useEffect(() => {\n    generateGrid();\n  }, []);\n\n  const generateGrid = (): void => {\n    let newGrid: Cell[][] = Array(gridSize).fill(null).map(() => \n      Array(gridSize).fill(null).map(() => ({\n        letter: String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n        selected: false\n      }))\n    );\n\n    words.forEach(word => {\n      placeWord(newGrid, word);\n    });\n\n    setGrid(newGrid);\n  };\n\n  const placeWord = (grid: Cell[][], word: string): void => {\n    const directions: Direction[] = [\n      [0, 1],  // horizontal\n      [1, 0],  // vertical\n      [1, 1],  // diagonal\n    ];\n\n    let placed = false;\n    while (!placed) {\n      const direction = directions[Math.floor(Math.random() * directions.length)];\n      const startX = Math.floor(Math.random() * gridSize);\n      const startY = Math.floor(Math.random() * gridSize);\n\n      if (canPlaceWord(grid, word, startX, startY, direction)) {\n        placeWordAt(grid, word, startX, startY, direction);\n        placed = true;\n      }\n    }\n  };\n\n  const canPlaceWord = (\n    grid: Cell[][],\n    word: string,\n    startX: number,\n    startY: number,\n    [dx, dy]: Direction\n  ): boolean => {\n    if (startX + dx * word.length >= gridSize || \n        startY + dy * word.length >= gridSize) return false;\n\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      if (grid[y][x].letter !== word[i] && \n          grid[y][x].letter !== String.fromCharCode(65 + Math.floor(Math.random() * 26))) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const placeWordAt = (\n    grid: Cell[][],\n    word: string,\n    startX: number,\n    startY: number,\n    [dx, dy]: Direction\n  ): void => {\n    for (let i = 0; i < word.length; i++) {\n      const x = startX + dx * i;\n      const y = startY + dy * i;\n      grid[y][x].letter = word[i];\n    }\n  };\n\n  const handleCellClick = (rowIndex: number, colIndex: number): void => {\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map(pos => grid[pos.row][pos.col].letter)\n      .join('');\n\n    if (words.includes(selectedWord)) {\n      onWordFound(selectedWord);\n    }\n\n    setTimeout(() => setSelection([]), 500);\n  };\n\n  return (\n    <div className=\"word-grid\">\n      {grid.map((row, rowIndex) => (\n        <div key={rowIndex} className=\"grid-row\">\n          {row.map((cell, colIndex) => (\n            <div\n              key={`${rowIndex}-${colIndex}`}\n              className={`grid-cell ${\n                selection.some(pos => pos.row === rowIndex && pos.col === colIndex)\n                  ? 'selected'\n                  : ''\n              }`}\n              onClick={() => handleCellClick(rowIndex, colIndex)}\n            >\n              {cell.letter}\n            </div>\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default WordGrid;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAmBnD,MAAMC,QAAiC,GAAGA,CAAC;EAAEC,KAAK;EAAEC;AAAY,CAAC,KAAK;EAAAC,EAAA;EACpE,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGV,QAAQ,CAAW,EAAE,CAAC;EAC9C,MAAM,CAACW,SAAS,EAAEC,YAAY,CAAC,GAAGZ,QAAQ,CAAa,EAAE,CAAC;EAE1DC,SAAS,CAAC,MAAM;IACdY,YAAY,CAAC,CAAC;EAChB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMA,YAAY,GAAGA,CAAA,KAAY;IAC/B,IAAIC,OAAiB,GAAGC,KAAK,CAACP,QAAQ,CAAC,CAACQ,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MACrDF,KAAK,CAACP,QAAQ,CAAC,CAACQ,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,OAAO;MACpCC,MAAM,EAAEC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;MAChEC,QAAQ,EAAE;IACZ,CAAC,CAAC,CACJ,CAAC;IAEDnB,KAAK,CAACoB,OAAO,CAACC,IAAI,IAAI;MACpBC,SAAS,CAACb,OAAO,EAAEY,IAAI,CAAC;IAC1B,CAAC,CAAC;IAEFhB,OAAO,CAACI,OAAO,CAAC;EAClB,CAAC;EAED,MAAMa,SAAS,GAAGA,CAAClB,IAAc,EAAEiB,IAAY,KAAW;IACxD,MAAME,UAAuB,GAAG,CAC9B,CAAC,CAAC,EAAE,CAAC,CAAC;IAAG;IACT,CAAC,CAAC,EAAE,CAAC,CAAC;IAAG;IACT,CAAC,CAAC,EAAE,CAAC,CAAC,CAAG;IAAA,CACV;IAED,IAAIC,MAAM,GAAG,KAAK;IAClB,OAAO,CAACA,MAAM,EAAE;MACd,MAAMC,SAAS,GAAGF,UAAU,CAACP,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGK,UAAU,CAACG,MAAM,CAAC,CAAC;MAC3E,MAAMC,MAAM,GAAGX,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGf,QAAQ,CAAC;MACnD,MAAMyB,MAAM,GAAGZ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGf,QAAQ,CAAC;MAEnD,IAAI0B,YAAY,CAACzB,IAAI,EAAEiB,IAAI,EAAEM,MAAM,EAAEC,MAAM,EAAEH,SAAS,CAAC,EAAE;QACvDK,WAAW,CAAC1B,IAAI,EAAEiB,IAAI,EAAEM,MAAM,EAAEC,MAAM,EAAEH,SAAS,CAAC;QAClDD,MAAM,GAAG,IAAI;MACf;IACF;EACF,CAAC;EAED,MAAMK,YAAY,GAAGA,CACnBzB,IAAc,EACdiB,IAAY,EACZM,MAAc,EACdC,MAAc,EACd,CAACG,EAAE,EAAEC,EAAE,CAAY,KACP;IACZ,IAAIL,MAAM,GAAGI,EAAE,GAAGV,IAAI,CAACK,MAAM,IAAIvB,QAAQ,IACrCyB,MAAM,GAAGI,EAAE,GAAGX,IAAI,CAACK,MAAM,IAAIvB,QAAQ,EAAE,OAAO,KAAK;IAEvD,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,IAAI,CAACK,MAAM,EAAEO,CAAC,EAAE,EAAE;MACpC,MAAMC,CAAC,GAAGP,MAAM,GAAGI,EAAE,GAAGE,CAAC;MACzB,MAAME,CAAC,GAAGP,MAAM,GAAGI,EAAE,GAAGC,CAAC;MACzB,IAAI7B,IAAI,CAAC+B,CAAC,CAAC,CAACD,CAAC,CAAC,CAACrB,MAAM,KAAKQ,IAAI,CAACY,CAAC,CAAC,IAC7B7B,IAAI,CAAC+B,CAAC,CAAC,CAACD,CAAC,CAAC,CAACrB,MAAM,KAAKC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;QAClF,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAED,MAAMY,WAAW,GAAGA,CAClB1B,IAAc,EACdiB,IAAY,EACZM,MAAc,EACdC,MAAc,EACd,CAACG,EAAE,EAAEC,EAAE,CAAY,KACV;IACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,IAAI,CAACK,MAAM,EAAEO,CAAC,EAAE,EAAE;MACpC,MAAMC,CAAC,GAAGP,MAAM,GAAGI,EAAE,GAAGE,CAAC;MACzB,MAAME,CAAC,GAAGP,MAAM,GAAGI,EAAE,GAAGC,CAAC;MACzB7B,IAAI,CAAC+B,CAAC,CAAC,CAACD,CAAC,CAAC,CAACrB,MAAM,GAAGQ,IAAI,CAACY,CAAC,CAAC;IAC7B;EACF,CAAC;EAED,MAAMG,eAAe,GAAGA,CAACC,QAAgB,EAAEC,QAAgB,KAAW;IACpE,MAAMC,YAAY,GAAG,CAAC,GAAGjC,SAAS,EAAE;MAAEkC,GAAG,EAAEH,QAAQ;MAAEI,GAAG,EAAEH;IAAS,CAAC,CAAC;IACrE/B,YAAY,CAACgC,YAAY,CAAC;IAE1B,MAAMG,YAAY,GAAGH,YAAY,CAC9B3B,GAAG,CAAC+B,GAAG,IAAIvC,IAAI,CAACuC,GAAG,CAACH,GAAG,CAAC,CAACG,GAAG,CAACF,GAAG,CAAC,CAAC5B,MAAM,CAAC,CACzC+B,IAAI,CAAC,EAAE,CAAC;IAEX,IAAI5C,KAAK,CAAC6C,QAAQ,CAACH,YAAY,CAAC,EAAE;MAChCzC,WAAW,CAACyC,YAAY,CAAC;IAC3B;IAEAI,UAAU,CAAC,MAAMvC,YAAY,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;EACzC,CAAC;EAED,oBACET,OAAA;IAAKiD,SAAS,EAAC,WAAW;IAAAC,QAAA,EACvB5C,IAAI,CAACQ,GAAG,CAAC,CAAC4B,GAAG,EAAEH,QAAQ,kBACtBvC,OAAA;MAAoBiD,SAAS,EAAC,UAAU;MAAAC,QAAA,EACrCR,GAAG,CAAC5B,GAAG,CAAC,CAACqC,IAAI,EAAEX,QAAQ,kBACtBxC,OAAA;QAEEiD,SAAS,EAAE,aACTzC,SAAS,CAAC4C,IAAI,CAACP,GAAG,IAAIA,GAAG,CAACH,GAAG,KAAKH,QAAQ,IAAIM,GAAG,CAACF,GAAG,KAAKH,QAAQ,CAAC,GAC/D,UAAU,GACV,EAAE,EACL;QACHa,OAAO,EAAEA,CAAA,KAAMf,eAAe,CAACC,QAAQ,EAAEC,QAAQ,CAAE;QAAAU,QAAA,EAElDC,IAAI,CAACpC;MAAM,GARP,GAAGwB,QAAQ,IAAIC,QAAQ,EAAE;QAAAc,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAS3B,CACN;IAAC,GAbMlB,QAAQ;MAAAe,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAcb,CACN;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;AAACrD,EAAA,CAnHIH,QAAiC;AAAAyD,EAAA,GAAjCzD,QAAiC;AAqHvC,eAAeA,QAAQ;AAAC,IAAAyD,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}