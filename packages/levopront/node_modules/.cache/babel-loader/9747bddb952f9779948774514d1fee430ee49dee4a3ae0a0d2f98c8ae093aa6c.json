{"ast":null,"code":"var _jsxFileName = \"/Users/micalumno/Documents/learning/word-search/packages/levopront/src/components/WordGrid.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { toast, ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\n\n// Increase grid size to accommodate longer words\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Add new state variables in the component\nconst WordGrid = ({\n  words,\n  onWordFound,\n  hintedWord\n}) => {\n  _s();\n  const gridSize = 15;\n  const [grid, setGrid] = useState(createEmptyGrid());\n  const [selection, setSelection] = useState([]);\n  const [foundPositions, setFoundPositions] = useState([]);\n  const [placedWords, setPlacedWords] = useState([]);\n  // Add state to preserve the initial grid\n  const [initializedGrid, setInitializedGrid] = useState([]);\n  function createEmptyGrid() {\n    return Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => ({\n      letter: \"\",\n      selected: false,\n      isPartOfHint: false,\n      wordIndex: undefined\n    })));\n  }\n  const directions = [[1, 0], [0, 1], [1, 1], [-1, 1], [-1, 0], [0, -1], [-1, -1], [1, -1]];\n\n  // Update useEffect for grid initialization\n  useEffect(() => {\n    const createGrid = () => {\n      let attempts = 0;\n      const maxAttempts = 1000;\n      while (attempts < maxAttempts) {\n        const newGrid = createEmptyGrid();\n        const placedWords = [];\n\n        // Process and shuffle words\n        const processedWords = [...words].map(word => ({\n          original: word,\n          processed: word.replace(/[^A-Za-z]/g, \"\").toUpperCase()\n        })).sort(() => Math.random() - 0.5).sort((a, b) => b.processed.length - a.processed.length);\n        let allWordsPlaced = true;\n\n        // Try to place each word\n        for (let wordIndex = 0; wordIndex < processedWords.length; wordIndex++) {\n          const {\n            processed: word,\n            original\n          } = processedWords[wordIndex];\n          let isPlaced = false;\n\n          // Shuffle directions for each word\n          const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);\n\n          // Try each direction\n          for (const [dx, dy] of shuffledDirections) {\n            if (isPlaced) break;\n\n            // Calculate valid range for this word\n            const maxX = dx === 0 ? gridSize : dx > 0 ? gridSize - word.length : gridSize;\n            const maxY = dy === 0 ? gridSize : dy > 0 ? gridSize - word.length : gridSize;\n            const minX = dx < 0 ? word.length - 1 : 0;\n            const minY = dy < 0 ? word.length - 1 : 0;\n\n            // Try each position\n            for (let y = minY; y < maxY && !isPlaced; y++) {\n              for (let x = minX; x < maxX && !isPlaced; x++) {\n                let canPlace = true;\n                const positions = [];\n\n                // Check if word fits\n                for (let i = 0; i < word.length && canPlace; i++) {\n                  const newX = x + dx * i;\n                  const newY = y + dy * i;\n                  if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {\n                    canPlace = false;\n                    break;\n                  }\n                  const currentCell = newGrid[newY][newX];\n                  if (currentCell.letter && currentCell.letter !== word[i]) {\n                    canPlace = false;\n                    break;\n                  }\n                  positions.push([newX, newY]);\n                }\n                if (canPlace && positions.length === word.length) {\n                  positions.forEach(([posX, posY], i) => {\n                    newGrid[posY][posX] = {\n                      letter: word[i],\n                      selected: false,\n                      isPartOfHint: false,\n                      wordIndex: wordIndex\n                    };\n                  });\n                  isPlaced = true;\n                  placedWords.push(original);\n                }\n              }\n            }\n          }\n          if (!isPlaced) {\n            allWordsPlaced = false;\n            break;\n          }\n        }\n        if (allWordsPlaced) {\n          // Fill remaining cells\n          for (let y = 0; y < gridSize; y++) {\n            for (let x = 0; x < gridSize; x++) {\n              if (!newGrid[y][x].letter) {\n                newGrid[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n              }\n            }\n          }\n          setPlacedWords(placedWords);\n          // Store the initial grid state\n          setInitializedGrid(JSON.parse(JSON.stringify(newGrid)));\n          return newGrid;\n        }\n        attempts++;\n      }\n      return createEmptyGrid();\n    };\n    const newGrid = createGrid();\n    setGrid(newGrid);\n  }, [words]);\n\n  // Add this new useEffect to handle found words\n  useEffect(() => {\n    if (initializedGrid.length > 0) {\n      const updatedGrid = JSON.parse(JSON.stringify(initializedGrid));\n      foundPositions.forEach(positions => {\n        positions.forEach(pos => {\n          if (updatedGrid[pos.row] && updatedGrid[pos.row][pos.col]) {\n            updatedGrid[pos.row][pos.col].found = true;\n            updatedGrid[pos.row][pos.col].selected = true;\n          }\n        });\n      });\n      setGrid(updatedGrid);\n    }\n  }, [foundPositions, initializedGrid]);\n\n  // Add state for celebration\n  const [showCelebration, setShowCelebration] = useState(false);\n  const [showFinalCelebration, setShowFinalCelebration] = useState(false);\n  const handleCellClick = (rowIndex, colIndex) => {\n    const isAlreadySelected = selection.some(pos => pos.row === rowIndex && pos.col === colIndex);\n    if (isAlreadySelected) {\n      setSelection([]);\n      return;\n    }\n    const newSelection = [...selection, {\n      row: rowIndex,\n      col: colIndex\n    }];\n    setSelection(newSelection);\n    const selectedWord = newSelection.map(pos => grid[pos.row][pos.col].letter).join(\"\");\n    const foundWord = words.find(word => word.replace(/[^A-Za-z]/g, \"\").toUpperCase() === selectedWord);\n    if (foundWord) {\n      toast.success(`Congratulations! You found \"${foundWord}\"!`, {\n        position: \"top-center\",\n        autoClose: 2000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true\n      });\n      onWordFound(foundWord);\n      setFoundPositions(prev => [...prev, newSelection]);\n      setSelection([]);\n\n      // Check if all words are found\n      if (foundPositions.length + 1 === words.length) {\n        setShowFinalCelebration(true);\n        setTimeout(() => setShowFinalCelebration(false), 5000);\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"word-grid\",\n    children: [/*#__PURE__*/_jsxDEV(ToastContainer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 259,\n      columnNumber: 7\n    }, this), showFinalCelebration && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"final-celebration-overlay\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"final-celebration-content\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"\\uD83C\\uDF89 Congratulations! \\uD83C\\uDF89\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 263,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"You've found all the words!\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 264,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"final-score\",\n          children: [\"Final Score: \", words.length * 100]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 265,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setShowFinalCelebration(false),\n          children: \"Close\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 266,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 262,\n        columnNumber: 11\n      }, this), [...Array(50)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"confetti\",\n        style: {\n          left: `${Math.random() * 100}%`,\n          animationDelay: `${Math.random() * 2}s`,\n          backgroundColor: `hsl(${Math.random() * 360}, 70%, 50%)`\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 269,\n        columnNumber: 13\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 9\n    }, this), showCelebration && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"celebration-overlay\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"celebration-text\",\n        children: [\"Congratulations!\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 285,\n          columnNumber: 13\n        }, this), \"You found all words!\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 283,\n        columnNumber: 11\n      }, this), [...Array(50)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"confetti\",\n        style: {\n          left: `${Math.random() * 100}%`,\n          backgroundColor: `hsl(${Math.random() * 360}, 70%, 50%)`,\n          animationDelay: `${Math.random() * 2}s`\n        }\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 289,\n        columnNumber: 13\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 282,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-container\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `grid-cell ${selection.some(pos => pos.row === rowIndex && pos.col === colIndex) ? \"selected\" : \"\"}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: cell.letter\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 305,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 258,\n    columnNumber: 5\n  }, this);\n};\n_s(WordGrid, \"b6Vl0Zl3XDSNkEuo2i9/2qh8M0s=\");\n_c = WordGrid;\nexport default WordGrid;\nvar _c;\n$RefreshReg$(_c, \"WordGrid\");","map":{"version":3,"names":["React","useState","useEffect","toast","ToastContainer","jsxDEV","_jsxDEV","WordGrid","words","onWordFound","hintedWord","_s","gridSize","grid","setGrid","createEmptyGrid","selection","setSelection","foundPositions","setFoundPositions","placedWords","setPlacedWords","initializedGrid","setInitializedGrid","Array","fill","map","letter","selected","isPartOfHint","wordIndex","undefined","directions","createGrid","attempts","maxAttempts","newGrid","processedWords","word","original","processed","replace","toUpperCase","sort","Math","random","a","b","length","allWordsPlaced","isPlaced","shuffledDirections","dx","dy","maxX","maxY","minX","minY","y","x","canPlace","positions","i","newX","newY","currentCell","push","forEach","posX","posY","String","fromCharCode","floor","JSON","parse","stringify","updatedGrid","pos","row","col","found","showCelebration","setShowCelebration","showFinalCelebration","setShowFinalCelebration","handleCellClick","rowIndex","colIndex","isAlreadySelected","some","newSelection","selectedWord","join","foundWord","find","success","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","prev","setTimeout","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_","style","left","animationDelay","backgroundColor","cell","_c","$RefreshReg$"],"sources":["/Users/micalumno/Documents/learning/word-search/packages/levopront/src/components/WordGrid.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { toast, ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\n\ninterface Position {\n  row: number;\n  col: number;\n}\n\ninterface Cell {\n  letter: string;\n  selected: boolean;\n  isPartOfHint: boolean;\n  wordIndex: number | undefined; // Updated type to allow both number and undefined\n}\n\ninterface WordGridProps {\n  words: string[];\n  onWordFound: (word: string) => void;\n  hintedWord?: string;\n}\n\n// Increase grid size to accommodate longer words\ninterface Timer {\n  minutes: number;\n  seconds: number;\n}\n\n// Add new state variables in the component\nconst WordGrid: React.FC<WordGridProps> = ({\n  words,\n  onWordFound,\n  hintedWord,\n}) => {\n  const gridSize = 15;\n  const [grid, setGrid] = useState<Cell[][]>(createEmptyGrid());\n  const [selection, setSelection] = useState<Position[]>([]);\n  const [foundPositions, setFoundPositions] = useState<Position[][]>([]);\n  const [placedWords, setPlacedWords] = useState<string[]>([]);\n  // Add state to preserve the initial grid\n  const [initializedGrid, setInitializedGrid] = useState<Cell[][]>([]);\n\n  function createEmptyGrid(): Cell[][] {\n    return Array(gridSize)\n      .fill(null)\n      .map(() =>\n        Array(gridSize)\n          .fill(null)\n          .map(() => ({\n            letter: \"\",\n            selected: false,\n            isPartOfHint: false,\n            wordIndex: undefined,\n          }))\n      );\n  }\n\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [1, 1],\n    [-1, 1],\n    [-1, 0],\n    [0, -1],\n    [-1, -1],\n    [1, -1],\n  ];\n\n  // Update useEffect for grid initialization\n  useEffect(() => {\n    const createGrid = () => {\n      let attempts = 0;\n      const maxAttempts = 1000;\n\n      while (attempts < maxAttempts) {\n        const newGrid = createEmptyGrid();\n        const placedWords: string[] = [];\n\n        // Process and shuffle words\n        const processedWords = [...words]\n          .map((word) => ({\n            original: word,\n            processed: word.replace(/[^A-Za-z]/g, \"\").toUpperCase(),\n          }))\n          .sort(() => Math.random() - 0.5)\n          .sort((a, b) => b.processed.length - a.processed.length);\n\n        let allWordsPlaced = true;\n\n        // Try to place each word\n        for (\n          let wordIndex = 0;\n          wordIndex < processedWords.length;\n          wordIndex++\n        ) {\n          const { processed: word, original } = processedWords[wordIndex];\n          let isPlaced = false;\n\n          // Shuffle directions for each word\n          const shuffledDirections = [...directions].sort(\n            () => Math.random() - 0.5\n          );\n\n          // Try each direction\n          for (const [dx, dy] of shuffledDirections) {\n            if (isPlaced) break;\n\n            // Calculate valid range for this word\n            const maxX =\n              dx === 0 ? gridSize : dx > 0 ? gridSize - word.length : gridSize;\n            const maxY =\n              dy === 0 ? gridSize : dy > 0 ? gridSize - word.length : gridSize;\n            const minX = dx < 0 ? word.length - 1 : 0;\n            const minY = dy < 0 ? word.length - 1 : 0;\n\n            // Try each position\n            for (let y = minY; y < maxY && !isPlaced; y++) {\n              for (let x = minX; x < maxX && !isPlaced; x++) {\n                let canPlace = true;\n                const positions: [number, number][] = [];\n\n                // Check if word fits\n                for (let i = 0; i < word.length && canPlace; i++) {\n                  const newX = x + dx * i;\n                  const newY = y + dy * i;\n\n                  if (\n                    newX < 0 ||\n                    newX >= gridSize ||\n                    newY < 0 ||\n                    newY >= gridSize\n                  ) {\n                    canPlace = false;\n                    break;\n                  }\n\n                  const currentCell = newGrid[newY][newX];\n                  if (currentCell.letter && currentCell.letter !== word[i]) {\n                    canPlace = false;\n                    break;\n                  }\n\n                  positions.push([newX, newY]);\n                }\n\n                if (canPlace && positions.length === word.length) {\n                  positions.forEach(([posX, posY], i) => {\n                    newGrid[posY][posX] = {\n                      letter: word[i],\n                      selected: false,\n                      isPartOfHint: false,\n                      wordIndex: wordIndex,\n                    };\n                  });\n                  isPlaced = true;\n                  placedWords.push(original);\n                }\n              }\n            }\n          }\n\n          if (!isPlaced) {\n            allWordsPlaced = false;\n            break;\n          }\n        }\n\n        if (allWordsPlaced) {\n          // Fill remaining cells\n          for (let y = 0; y < gridSize; y++) {\n            for (let x = 0; x < gridSize; x++) {\n              if (!newGrid[y][x].letter) {\n                newGrid[y][x].letter = String.fromCharCode(\n                  65 + Math.floor(Math.random() * 26)\n                );\n              }\n            }\n          }\n          setPlacedWords(placedWords);\n          // Store the initial grid state\n          setInitializedGrid(JSON.parse(JSON.stringify(newGrid)));\n          return newGrid;\n        }\n\n        attempts++;\n      }\n\n      return createEmptyGrid();\n    };\n\n    const newGrid = createGrid();\n    setGrid(newGrid);\n  }, [words]);\n\n  // Add this new useEffect to handle found words\n  useEffect(() => {\n    if (initializedGrid.length > 0) {\n      const updatedGrid = JSON.parse(JSON.stringify(initializedGrid));\n      foundPositions.forEach((positions) => {\n        positions.forEach((pos) => {\n          if (updatedGrid[pos.row] && updatedGrid[pos.row][pos.col]) {\n            updatedGrid[pos.row][pos.col].found = true;\n            updatedGrid[pos.row][pos.col].selected = true;\n          }\n        });\n      });\n      setGrid(updatedGrid);\n    }\n  }, [foundPositions, initializedGrid]);\n\n  // Add state for celebration\n  const [showCelebration, setShowCelebration] = useState(false);\n  const [showFinalCelebration, setShowFinalCelebration] = useState(false);\n\n  const handleCellClick = (rowIndex: number, colIndex: number) => {\n    const isAlreadySelected = selection.some(\n      (pos) => pos.row === rowIndex && pos.col === colIndex\n    );\n\n    if (isAlreadySelected) {\n      setSelection([]);\n      return;\n    }\n\n    const newSelection = [...selection, { row: rowIndex, col: colIndex }];\n    setSelection(newSelection);\n\n    const selectedWord = newSelection\n      .map((pos) => grid[pos.row][pos.col].letter)\n      .join(\"\");\n\n    const foundWord = words.find(\n      (word) => word.replace(/[^A-Za-z]/g, \"\").toUpperCase() === selectedWord\n    );\n\n    if (foundWord) {\n      toast.success(`Congratulations! You found \"${foundWord}\"!`, {\n        position: \"top-center\",\n        autoClose: 2000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n      });\n      onWordFound(foundWord);\n      setFoundPositions((prev) => [...prev, newSelection]);\n      setSelection([]);\n\n      // Check if all words are found\n      if (foundPositions.length + 1 === words.length) {\n        setShowFinalCelebration(true);\n        setTimeout(() => setShowFinalCelebration(false), 5000);\n      }\n    }\n  };\n\n  return (\n    <div className=\"word-grid\">\n      <ToastContainer />\n      {showFinalCelebration && (\n        <div className=\"final-celebration-overlay\">\n          <div className=\"final-celebration-content\">\n            <h2>🎉 Congratulations! 🎉</h2>\n            <p>You've found all the words!</p>\n            <div className=\"final-score\">Final Score: {words.length * 100}</div>\n            <button onClick={() => setShowFinalCelebration(false)}>Close</button>\n          </div>\n          {[...Array(50)].map((_, i) => (\n            <div\n              key={i}\n              className=\"confetti\"\n              style={{\n                left: `${Math.random() * 100}%`,\n                animationDelay: `${Math.random() * 2}s`,\n                backgroundColor: `hsl(${Math.random() * 360}, 70%, 50%)`,\n              }}\n            />\n          ))}\n        </div>\n      )}\n      {showCelebration && (\n        <div className=\"celebration-overlay\">\n          <div className=\"celebration-text\">\n            Congratulations!\n            <br />\n            You found all words!\n          </div>\n          {[...Array(50)].map((_, i) => (\n            <div\n              key={i}\n              className=\"confetti\"\n              style={{\n                left: `${Math.random() * 100}%`,\n                backgroundColor: `hsl(${Math.random() * 360}, 70%, 50%)`,\n                animationDelay: `${Math.random() * 2}s`,\n              }}\n            />\n          ))}\n        </div>\n      )}\n      <div className=\"grid-container\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((cell, colIndex) => (\n              <div\n                key={`${rowIndex}-${colIndex}`}\n                className={`grid-cell ${\n                  selection.some(\n                    (pos) => pos.row === rowIndex && pos.col === colIndex\n                  )\n                    ? \"selected\"\n                    : \"\"\n                }`}\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {cell.letter}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default WordGrid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}