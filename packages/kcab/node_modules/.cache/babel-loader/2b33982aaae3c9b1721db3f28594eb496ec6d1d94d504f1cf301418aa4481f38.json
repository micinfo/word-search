{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useState, useEffect } from \"react\";\nimport { toast, ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\n// Add new state variables in the component\nvar WordGrid = function (_a) {\n  var words = _a.words,\n    onWordFound = _a.onWordFound,\n    hintedWord = _a.hintedWord;\n  var gridSize = 15;\n  var _b = useState(createEmptyGrid()),\n    grid = _b[0],\n    setGrid = _b[1];\n  var _c = useState([]),\n    selection = _c[0],\n    setSelection = _c[1];\n  var _d = useState([]),\n    foundPositions = _d[0],\n    setFoundPositions = _d[1];\n  var _e = useState([]),\n    placedWords = _e[0],\n    setPlacedWords = _e[1];\n  // Add state to preserve the initial grid\n  var _f = useState([]),\n    initializedGrid = _f[0],\n    setInitializedGrid = _f[1];\n  function createEmptyGrid() {\n    return Array(gridSize).fill(null).map(function () {\n      return Array(gridSize).fill(null).map(function () {\n        return {\n          letter: \"\",\n          selected: false,\n          isPartOfHint: false,\n          wordIndex: undefined\n        };\n      });\n    });\n  }\n  var directions = [[1, 0], [0, 1], [1, 1], [-1, 1], [-1, 0], [0, -1], [-1, -1], [1, -1]];\n  // Update useEffect for grid initialization\n  useEffect(function () {\n    var createGrid = function () {\n      var attempts = 0;\n      var maxAttempts = 1000;\n      var _loop_1 = function () {\n        var newGrid_1 = createEmptyGrid();\n        var placedWords_1 = [];\n        // Process and shuffle words\n        var processedWords = __spreadArray([], words, true).map(function (word) {\n          return {\n            original: word,\n            processed: word.replace(/[^A-Za-z]/g, \"\").toUpperCase()\n          };\n        }).sort(function () {\n          return Math.random() - 0.5;\n        }).sort(function (a, b) {\n          return b.processed.length - a.processed.length;\n        });\n        var allWordsPlaced = true;\n        var _loop_2 = function (wordIndex) {\n          var _a = processedWords[wordIndex],\n            word = _a.processed,\n            original = _a.original;\n          var isPlaced = false;\n          // Shuffle directions for each word\n          var shuffledDirections = __spreadArray([], directions, true).sort(function () {\n            return Math.random() - 0.5;\n          });\n          // Try each direction\n          for (var _i = 0, shuffledDirections_1 = shuffledDirections; _i < shuffledDirections_1.length; _i++) {\n            var _b = shuffledDirections_1[_i],\n              dx = _b[0],\n              dy = _b[1];\n            if (isPlaced) break;\n            // Calculate valid range for this word\n            var maxX = dx === 0 ? gridSize : dx > 0 ? gridSize - word.length : gridSize;\n            var maxY = dy === 0 ? gridSize : dy > 0 ? gridSize - word.length : gridSize;\n            var minX = dx < 0 ? word.length - 1 : 0;\n            var minY = dy < 0 ? word.length - 1 : 0;\n            // Try each position\n            for (var y = minY; y < maxY && !isPlaced; y++) {\n              for (var x = minX; x < maxX && !isPlaced; x++) {\n                var canPlace = true;\n                var positions = [];\n                // Check if word fits\n                for (var i = 0; i < word.length && canPlace; i++) {\n                  var newX = x + dx * i;\n                  var newY = y + dy * i;\n                  if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {\n                    canPlace = false;\n                    break;\n                  }\n                  var currentCell = newGrid_1[newY][newX];\n                  if (currentCell.letter && currentCell.letter !== word[i]) {\n                    canPlace = false;\n                    break;\n                  }\n                  positions.push([newX, newY]);\n                }\n                if (canPlace && positions.length === word.length) {\n                  positions.forEach(function (_a, i) {\n                    var posX = _a[0],\n                      posY = _a[1];\n                    newGrid_1[posY][posX] = {\n                      letter: word[i],\n                      selected: false,\n                      isPartOfHint: false,\n                      wordIndex: wordIndex\n                    };\n                  });\n                  isPlaced = true;\n                  placedWords_1.push(original);\n                }\n              }\n            }\n          }\n          if (!isPlaced) {\n            allWordsPlaced = false;\n            return \"break\";\n          }\n        };\n        // Try to place each word\n        for (var wordIndex = 0; wordIndex < processedWords.length; wordIndex++) {\n          var state_2 = _loop_2(wordIndex);\n          if (state_2 === \"break\") break;\n        }\n        if (allWordsPlaced) {\n          // Fill remaining cells\n          for (var y = 0; y < gridSize; y++) {\n            for (var x = 0; x < gridSize; x++) {\n              if (!newGrid_1[y][x].letter) {\n                newGrid_1[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n              }\n            }\n          }\n          setPlacedWords(placedWords_1);\n          // Store the initial grid state\n          setInitializedGrid(JSON.parse(JSON.stringify(newGrid_1)));\n          return {\n            value: newGrid_1\n          };\n        }\n        attempts++;\n      };\n      while (attempts < maxAttempts) {\n        var state_1 = _loop_1();\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n      return createEmptyGrid();\n    };\n    var newGrid = createGrid();\n    setGrid(newGrid);\n  }, [words]);\n  // Add this new useEffect to handle found words\n  useEffect(function () {\n    if (initializedGrid.length > 0) {\n      var updatedGrid_1 = JSON.parse(JSON.stringify(initializedGrid));\n      foundPositions.forEach(function (positions) {\n        positions.forEach(function (pos) {\n          if (updatedGrid_1[pos.row] && updatedGrid_1[pos.row][pos.col]) {\n            updatedGrid_1[pos.row][pos.col].found = true;\n            updatedGrid_1[pos.row][pos.col].selected = true;\n          }\n        });\n      });\n      setGrid(updatedGrid_1);\n    }\n  }, [foundPositions, initializedGrid]);\n  // Add state for celebration\n  var _g = useState(false),\n    showCelebration = _g[0],\n    setShowCelebration = _g[1];\n  var _h = useState(false),\n    showFinalCelebration = _h[0],\n    setShowFinalCelebration = _h[1];\n  var handleCellClick = function (rowIndex, colIndex) {\n    var isAlreadySelected = selection.some(function (pos) {\n      return pos.row === rowIndex && pos.col === colIndex;\n    });\n    if (isAlreadySelected) {\n      setSelection([]);\n      return;\n    }\n    var newSelection = __spreadArray(__spreadArray([], selection, true), [{\n      row: rowIndex,\n      col: colIndex\n    }], false);\n    setSelection(newSelection);\n    var selectedWord = newSelection.map(function (pos) {\n      return grid[pos.row][pos.col].letter;\n    }).join(\"\");\n    var foundWord = words.find(function (word) {\n      return word.replace(/[^A-Za-z]/g, \"\").toUpperCase() === selectedWord;\n    });\n    if (foundWord) {\n      toast.success(\"Congratulations! You found \\\"\".concat(foundWord, \"\\\"!\"), {\n        position: \"top-center\",\n        autoClose: 2000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true\n      });\n      onWordFound(foundWord);\n      setFoundPositions(function (prev) {\n        return __spreadArray(__spreadArray([], prev, true), [newSelection], false);\n      });\n      setSelection([]);\n      // Check if all words are found\n      if (foundPositions.length + 1 === words.length) {\n        setShowFinalCelebration(true);\n        setTimeout(function () {\n          return setShowFinalCelebration(false);\n        }, 5000);\n      }\n    }\n  };\n  return _jsxs(\"div\", __assign({\n    className: \"word-grid\"\n  }, {\n    children: [_jsx(ToastContainer, {}), showFinalCelebration && _jsxs(\"div\", __assign({\n      className: \"final-celebration-overlay\"\n    }, {\n      children: [_jsxs(\"div\", __assign({\n        className: \"final-celebration-content\"\n      }, {\n        children: [_jsx(\"h2\", {\n          children: \"\\uD83C\\uDF89 Congratulations! \\uD83C\\uDF89\"\n        }), _jsx(\"p\", {\n          children: \"You've found all the words!\"\n        }), _jsxs(\"div\", __assign({\n          className: \"final-score\"\n        }, {\n          children: [\"Final Score: \", words.length * 100]\n        })), _jsx(\"button\", __assign({\n          onClick: function () {\n            return setShowFinalCelebration(false);\n          }\n        }, {\n          children: \"Close\"\n        }))]\n      })), __spreadArray([], Array(50), true).map(function (_, i) {\n        return _jsx(\"div\", {\n          className: \"confetti\",\n          style: {\n            left: \"\".concat(Math.random() * 100, \"%\"),\n            animationDelay: \"\".concat(Math.random() * 2, \"s\"),\n            backgroundColor: \"hsl(\".concat(Math.random() * 360, \", 70%, 50%)\")\n          }\n        }, i);\n      })]\n    })), showCelebration && _jsxs(\"div\", __assign({\n      className: \"celebration-overlay\"\n    }, {\n      children: [_jsxs(\"div\", __assign({\n        className: \"celebration-text\"\n      }, {\n        children: [\"Congratulations!\", _jsx(\"br\", {}), \"You found all words!\"]\n      })), __spreadArray([], Array(50), true).map(function (_, i) {\n        return _jsx(\"div\", {\n          className: \"confetti\",\n          style: {\n            left: \"\".concat(Math.random() * 100, \"%\"),\n            backgroundColor: \"hsl(\".concat(Math.random() * 360, \", 70%, 50%)\"),\n            animationDelay: \"\".concat(Math.random() * 2, \"s\")\n          }\n        }, i);\n      })]\n    })), _jsx(\"div\", __assign({\n      className: \"grid-container\"\n    }, {\n      children: grid.map(function (row, rowIndex) {\n        return _jsx(\"div\", __assign({\n          className: \"grid-row\"\n        }, {\n          children: row.map(function (cell, colIndex) {\n            return _jsx(\"div\", __assign({\n              className: \"grid-cell \".concat(selection.some(function (pos) {\n                return pos.row === rowIndex && pos.col === colIndex;\n              }) ? \"selected\" : \"\"),\n              onClick: function () {\n                return handleCellClick(rowIndex, colIndex);\n              }\n            }, {\n              children: cell.letter\n            }), \"\".concat(rowIndex, \"-\").concat(colIndex));\n          })\n        }), rowIndex);\n      })\n    }))]\n  }));\n};\nexport default WordGrid;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","jsx","_jsx","jsxs","_jsxs","useState","useEffect","toast","ToastContainer","WordGrid","_a","words","onWordFound","hintedWord","gridSize","_b","createEmptyGrid","grid","setGrid","_c","selection","setSelection","_d","foundPositions","setFoundPositions","_e","placedWords","setPlacedWords","_f","initializedGrid","setInitializedGrid","fill","map","letter","selected","isPartOfHint","wordIndex","undefined","directions","createGrid","attempts","maxAttempts","_loop_1","newGrid_1","placedWords_1","processedWords","word","original","processed","replace","toUpperCase","sort","Math","random","a","b","allWordsPlaced","_loop_2","isPlaced","shuffledDirections","_i","shuffledDirections_1","dx","dy","maxX","maxY","minX","minY","y","x","canPlace","positions","newX","newY","currentCell","push","forEach","posX","posY","state_2","String","fromCharCode","floor","JSON","parse","stringify","value","state_1","newGrid","updatedGrid_1","pos","row","col","found","_g","showCelebration","setShowCelebration","_h","showFinalCelebration","setShowFinalCelebration","handleCellClick","rowIndex","colIndex","isAlreadySelected","some","newSelection","selectedWord","join","foundWord","find","success","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","prev","setTimeout","className","children","onClick","_","style","left","animationDelay","backgroundColor","cell"],"sources":["/Users/micalumno/Documents/learning/word-search/packages/shared/dist/components/WordGrid.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useState, useEffect } from \"react\";\nimport { toast, ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\n// Add new state variables in the component\nvar WordGrid = function (_a) {\n    var words = _a.words, onWordFound = _a.onWordFound, hintedWord = _a.hintedWord;\n    var gridSize = 15;\n    var _b = useState(createEmptyGrid()), grid = _b[0], setGrid = _b[1];\n    var _c = useState([]), selection = _c[0], setSelection = _c[1];\n    var _d = useState([]), foundPositions = _d[0], setFoundPositions = _d[1];\n    var _e = useState([]), placedWords = _e[0], setPlacedWords = _e[1];\n    // Add state to preserve the initial grid\n    var _f = useState([]), initializedGrid = _f[0], setInitializedGrid = _f[1];\n    function createEmptyGrid() {\n        return Array(gridSize)\n            .fill(null)\n            .map(function () {\n            return Array(gridSize)\n                .fill(null)\n                .map(function () { return ({\n                letter: \"\",\n                selected: false,\n                isPartOfHint: false,\n                wordIndex: undefined,\n            }); });\n        });\n    }\n    var directions = [\n        [1, 0],\n        [0, 1],\n        [1, 1],\n        [-1, 1],\n        [-1, 0],\n        [0, -1],\n        [-1, -1],\n        [1, -1],\n    ];\n    // Update useEffect for grid initialization\n    useEffect(function () {\n        var createGrid = function () {\n            var attempts = 0;\n            var maxAttempts = 1000;\n            var _loop_1 = function () {\n                var newGrid_1 = createEmptyGrid();\n                var placedWords_1 = [];\n                // Process and shuffle words\n                var processedWords = __spreadArray([], words, true).map(function (word) { return ({\n                    original: word,\n                    processed: word.replace(/[^A-Za-z]/g, \"\").toUpperCase(),\n                }); })\n                    .sort(function () { return Math.random() - 0.5; })\n                    .sort(function (a, b) { return b.processed.length - a.processed.length; });\n                var allWordsPlaced = true;\n                var _loop_2 = function (wordIndex) {\n                    var _a = processedWords[wordIndex], word = _a.processed, original = _a.original;\n                    var isPlaced = false;\n                    // Shuffle directions for each word\n                    var shuffledDirections = __spreadArray([], directions, true).sort(function () { return Math.random() - 0.5; });\n                    // Try each direction\n                    for (var _i = 0, shuffledDirections_1 = shuffledDirections; _i < shuffledDirections_1.length; _i++) {\n                        var _b = shuffledDirections_1[_i], dx = _b[0], dy = _b[1];\n                        if (isPlaced)\n                            break;\n                        // Calculate valid range for this word\n                        var maxX = dx === 0 ? gridSize : dx > 0 ? gridSize - word.length : gridSize;\n                        var maxY = dy === 0 ? gridSize : dy > 0 ? gridSize - word.length : gridSize;\n                        var minX = dx < 0 ? word.length - 1 : 0;\n                        var minY = dy < 0 ? word.length - 1 : 0;\n                        // Try each position\n                        for (var y = minY; y < maxY && !isPlaced; y++) {\n                            for (var x = minX; x < maxX && !isPlaced; x++) {\n                                var canPlace = true;\n                                var positions = [];\n                                // Check if word fits\n                                for (var i = 0; i < word.length && canPlace; i++) {\n                                    var newX = x + dx * i;\n                                    var newY = y + dy * i;\n                                    if (newX < 0 ||\n                                        newX >= gridSize ||\n                                        newY < 0 ||\n                                        newY >= gridSize) {\n                                        canPlace = false;\n                                        break;\n                                    }\n                                    var currentCell = newGrid_1[newY][newX];\n                                    if (currentCell.letter && currentCell.letter !== word[i]) {\n                                        canPlace = false;\n                                        break;\n                                    }\n                                    positions.push([newX, newY]);\n                                }\n                                if (canPlace && positions.length === word.length) {\n                                    positions.forEach(function (_a, i) {\n                                        var posX = _a[0], posY = _a[1];\n                                        newGrid_1[posY][posX] = {\n                                            letter: word[i],\n                                            selected: false,\n                                            isPartOfHint: false,\n                                            wordIndex: wordIndex,\n                                        };\n                                    });\n                                    isPlaced = true;\n                                    placedWords_1.push(original);\n                                }\n                            }\n                        }\n                    }\n                    if (!isPlaced) {\n                        allWordsPlaced = false;\n                        return \"break\";\n                    }\n                };\n                // Try to place each word\n                for (var wordIndex = 0; wordIndex < processedWords.length; wordIndex++) {\n                    var state_2 = _loop_2(wordIndex);\n                    if (state_2 === \"break\")\n                        break;\n                }\n                if (allWordsPlaced) {\n                    // Fill remaining cells\n                    for (var y = 0; y < gridSize; y++) {\n                        for (var x = 0; x < gridSize; x++) {\n                            if (!newGrid_1[y][x].letter) {\n                                newGrid_1[y][x].letter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\n                            }\n                        }\n                    }\n                    setPlacedWords(placedWords_1);\n                    // Store the initial grid state\n                    setInitializedGrid(JSON.parse(JSON.stringify(newGrid_1)));\n                    return { value: newGrid_1 };\n                }\n                attempts++;\n            };\n            while (attempts < maxAttempts) {\n                var state_1 = _loop_1();\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n            return createEmptyGrid();\n        };\n        var newGrid = createGrid();\n        setGrid(newGrid);\n    }, [words]);\n    // Add this new useEffect to handle found words\n    useEffect(function () {\n        if (initializedGrid.length > 0) {\n            var updatedGrid_1 = JSON.parse(JSON.stringify(initializedGrid));\n            foundPositions.forEach(function (positions) {\n                positions.forEach(function (pos) {\n                    if (updatedGrid_1[pos.row] && updatedGrid_1[pos.row][pos.col]) {\n                        updatedGrid_1[pos.row][pos.col].found = true;\n                        updatedGrid_1[pos.row][pos.col].selected = true;\n                    }\n                });\n            });\n            setGrid(updatedGrid_1);\n        }\n    }, [foundPositions, initializedGrid]);\n    // Add state for celebration\n    var _g = useState(false), showCelebration = _g[0], setShowCelebration = _g[1];\n    var _h = useState(false), showFinalCelebration = _h[0], setShowFinalCelebration = _h[1];\n    var handleCellClick = function (rowIndex, colIndex) {\n        var isAlreadySelected = selection.some(function (pos) { return pos.row === rowIndex && pos.col === colIndex; });\n        if (isAlreadySelected) {\n            setSelection([]);\n            return;\n        }\n        var newSelection = __spreadArray(__spreadArray([], selection, true), [{ row: rowIndex, col: colIndex }], false);\n        setSelection(newSelection);\n        var selectedWord = newSelection\n            .map(function (pos) { return grid[pos.row][pos.col].letter; })\n            .join(\"\");\n        var foundWord = words.find(function (word) { return word.replace(/[^A-Za-z]/g, \"\").toUpperCase() === selectedWord; });\n        if (foundWord) {\n            toast.success(\"Congratulations! You found \\\"\".concat(foundWord, \"\\\"!\"), {\n                position: \"top-center\",\n                autoClose: 2000,\n                hideProgressBar: false,\n                closeOnClick: true,\n                pauseOnHover: true,\n                draggable: true,\n            });\n            onWordFound(foundWord);\n            setFoundPositions(function (prev) { return __spreadArray(__spreadArray([], prev, true), [newSelection], false); });\n            setSelection([]);\n            // Check if all words are found\n            if (foundPositions.length + 1 === words.length) {\n                setShowFinalCelebration(true);\n                setTimeout(function () { return setShowFinalCelebration(false); }, 5000);\n            }\n        }\n    };\n    return (_jsxs(\"div\", __assign({ className: \"word-grid\" }, { children: [_jsx(ToastContainer, {}), showFinalCelebration && (_jsxs(\"div\", __assign({ className: \"final-celebration-overlay\" }, { children: [_jsxs(\"div\", __assign({ className: \"final-celebration-content\" }, { children: [_jsx(\"h2\", { children: \"\\uD83C\\uDF89 Congratulations! \\uD83C\\uDF89\" }), _jsx(\"p\", { children: \"You've found all the words!\" }), _jsxs(\"div\", __assign({ className: \"final-score\" }, { children: [\"Final Score: \", words.length * 100] })), _jsx(\"button\", __assign({ onClick: function () { return setShowFinalCelebration(false); } }, { children: \"Close\" }))] })), __spreadArray([], Array(50), true).map(function (_, i) { return (_jsx(\"div\", { className: \"confetti\", style: {\n                            left: \"\".concat(Math.random() * 100, \"%\"),\n                            animationDelay: \"\".concat(Math.random() * 2, \"s\"),\n                            backgroundColor: \"hsl(\".concat(Math.random() * 360, \", 70%, 50%)\"),\n                        } }, i)); })] }))), showCelebration && (_jsxs(\"div\", __assign({ className: \"celebration-overlay\" }, { children: [_jsxs(\"div\", __assign({ className: \"celebration-text\" }, { children: [\"Congratulations!\", _jsx(\"br\", {}), \"You found all words!\"] })), __spreadArray([], Array(50), true).map(function (_, i) { return (_jsx(\"div\", { className: \"confetti\", style: {\n                            left: \"\".concat(Math.random() * 100, \"%\"),\n                            backgroundColor: \"hsl(\".concat(Math.random() * 360, \", 70%, 50%)\"),\n                            animationDelay: \"\".concat(Math.random() * 2, \"s\"),\n                        } }, i)); })] }))), _jsx(\"div\", __assign({ className: \"grid-container\" }, { children: grid.map(function (row, rowIndex) { return (_jsx(\"div\", __assign({ className: \"grid-row\" }, { children: row.map(function (cell, colIndex) { return (_jsx(\"div\", __assign({ className: \"grid-cell \".concat(selection.some(function (pos) { return pos.row === rowIndex && pos.col === colIndex; })\n                            ? \"selected\"\n                            : \"\"), onClick: function () { return handleCellClick(rowIndex, colIndex); } }, { children: cell.letter }), \"\".concat(rowIndex, \"-\").concat(colIndex))); }) }), rowIndex)); }) }))] })));\n};\nexport default WordGrid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}